위임생성자 : 생성자가 다른 생성자를 사용하는것. 
같은 기능을 하는 함수는 하나만 있는게 좋기에
 오버로딩을 이용해서 위임생성자 기능을 이용한다.

소멸자 :
- 클래스가 소멸될때 호출되는 함수. 
- ~CLASSNAME() 과 같은 식으로 사용함 파라미터는 없음.
- 중괄호 영역을 벗어날 때 호출됨.
- CPP에서는 delete해줄 때 자주 쓰임. ex) 배열 delete[] m_arr
- 불안하면 그냥 vector를 쓰자.

this 포인터와 연쇄 호출
- 클래스 -> 인스턴스 
      찍어냄

- 어떻게 분간? this pointer 이용 ( 자기 자신의 주소 )
- 함수는 모든 인스턴스가 공유하는데 이를 분간하기 위해 
  함수에 this->가 숨어있음. setID(1)를 호출한다고하면
- setID(&s2, 4)처럼 들어간다고 생각하면 됨.

Chaining member function
- Calc& add(int value) { m_value += value; return *this; }
- Calc& sub(int value) { m_value -= value; return *this; } 
- Calc cal(10);
- calc.add(10).sub(5);
이런식으로 쓸 수 있다.

- template을 구현한다거나 할 때는 헤더에 코드를 넣는 경우도 있음.
클래스의 instance를 const로 설정하면
멤버 함수에 int getValue() const { return m_value; }
와 같은 함수만 사용할 수 있다. 안에있는 m_value의 값을 바꾸지 않는다는 뜻

- const로 막아둘 수 있는 곳은 전부 const로 막아두자.

- class내에서 파라미터에 인스턴스가 복사될경우, 다음과 같은 copy constructor가 호출된다.
Something(const Something& st_in)
{
    m_value = st_in.m_value;
}

- 파라미터에 복사가되는걸 막으려면 const TypeName &parameterName을 쓰면 좋다.
함수에 const선언을하면 리턴타입에도 const를 사용하는것이 일반적이다.

- 정적 멤버변수 
static
클래스 내부에서 static 변수. extern등 앞에있는 강의 참고.
클래스에서 유래된 모든 인스턴스가 static value를 공유하게 됨.
static member의 경우 define in cpp, cpp안에다가 정의하자. 안그럼 에러남

- 정적 멤버 함수
특정 인스턴스와 상관없이 함수를 사용하고 싶을때 사용
주의할점. this포인터를 사용할 수 없다. non-static member function에서만 사용할 수 있음.
이에따라 this로 접근해야하는 모든게 안됨.

- 멤버함수는 함수포인터를 이용해 가져오려면 멤버함수의 주소가 같기 때문에 
int (Something::*fptr1)() = &Something::temp; 이런식으로 가져와야한다
cout << (s2.*fptr1)() << endl; 

- static의 경우 
int (*fptr2)() = &Something::getValue;
와 같이 가져옴

- member function은 인스턴스에 종속되지 않는다.
static member variable은 constructor에서 초기화를 시켜줄 수가 없다.
static 생성자는 현재 cpp에서 지원해주지 않는다. 

inner class 
클래스안의 클래스. 이걸 이용하면 s_value를 초기화해줄 수 있다. 내부 클래스이기 때문
static _init s_initializer;를 클래스의 멤버펑션에 집어넣음으로써 
inner class의 생성자를 호출시키고 그 뒤에 static member variable을 초기화한다.
간접적으로 초기화가 가능하긴함.

friend function And class 
객체지향의 기본원칙 encapsulation을 유지하기 위해 friend를 쓰면 깔끔하게 정리할 수 있음
어떤 함수가 클래스 A에 있는 private 멤버에 접근하고 싶음. 
이럴때는 그 함수를 클래스내부에 클래스 A의 친구로 선언해주됨. 
연산자 오버로딩에서 자주 쓰임.
ex) friend void doSomething(A& a);
전방선언
클래스 내부에 있는 함수를 친구로 선언하고 싶다.
ex.1) friend class B
ex.2) friend void B::doSomething(A& a)

전방선언을 피하기 위해

선언만 class안에 넣어두고 함수는 밖으로 빼면 좋다.

- 익명 객체 
이름을 넣지않고 객체만 선언. l-value가 아닌 r-value처럼 작동함.
ex) A().print(); 
int(6) + int(8) // 캐스팅이라고 배웠는데 익명객체로 덧셈임. 


- nested types 
클래스 안에서만 자료형을 선언. 클래스 안에 포함된 자료형
특정 클래스에서만 사용되는 데이터 타입 -> enum타입을 class안에 넣어버림
enum class -> Fruit::FruitType::APPLE과 같이 1단계 더들어감.

- 실행 시간 측정하기.


- 연산자 오버로딩하기.
사용자 정의 자료형끼리도 산술연산자 사용가능. 

ex) friend Cents operator + (const Cents &c1, const Cents &c2)
    {
      return c1.m_value + c2.m_value;
    }
-> 멤버로 떼면 컴파일러 에러남. too many parameter
   왼쪽에있는 파라미터를 this로 대체해야함. 
   +는 원래 unary operator이기떄문

?:, ::, sizeof, .(member selection), .*은 연산자 오버로딩이 안된다.
^ 연산자는 연산순위가 매우 낮으니 특별한 기능이 있도록 오버로딩하려면 괄호로 싸고 왠만하면 오버로딩을 하지말자.
연산자 오버로딩을 해도 연산자 우선순위는 그대로이니 조심하자.

=, [], (), -> // member function 형태로만 오버로딩이 가능하다.

